# [나무 재테크](https://www.acmicpc.net/problem/16235)

문제를 처음 보았을 때는 단순한 시뮬레이션 문제라고 생각해서 for문만 써서 문제를 풀었습니다. 
하지만 문제의 시간 제한이 0.3초로 매우 짧은 편이었고 '시간 초과'라는 결과를 얻었습니다.

아래의 코드로 수정하고 나서 통과할 수 있었습니다.

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <queue>
#define MAXN 12

using namespace std;

struct Tree {
	int age, r, c;
};

vector<int> trees[MAXN][MAXN];

int treeplus[MAXN][MAXN], a[MAXN][MAXN];
int N, M, K;

bool isPossi(int r, int c) {
	return (r >= 1 && r <= N && c >= 1 && c <= N);
}
int dr[] = { -1,-1,0,1,1,1,0,-1 }, dc[] = { 0,1,1,1,0,-1,-1,-1 };

vector<Tree> liveTree;
vector<Tree> deadTree;
vector<int> temp;

int Solve() {
	bool plusCheck[130];
	int total_plus;
	int nr, nc, sz, start, age;

	while (K--) {
		liveTree.clear();
		deadTree.clear();

		// 봄
		for (int r = 1; r <= N; r++) {
			for (int c = 1; c <= N; c++) {
				// 겨울
				if (trees[r][c].empty()) {
					treeplus[r][c] += a[r][c];
					continue;
				}

				temp.clear();
				sort(trees[r][c].begin(), trees[r][c].end());

				for (int k = 0; k < trees[r][c].size(); k++) {
					age = trees[r][c][k];
					if (treeplus[r][c] >= age) {
						treeplus[r][c] -= age;
						temp.push_back(age + 1);

						if ((age + 1) % 5 == 0)
							liveTree.push_back({ age + 1, r, c });
					}
					else {
						deadTree.push_back({ age / 2, r, c });
					}
				}

				trees[r][c] = temp;
				// 겨울
				treeplus[r][c] += a[r][c];
			}
		}

		// 여름
		for (Tree t : deadTree) {
			treeplus[t.r][t.c] += t.age;
		}

		// 가을
		for (Tree t : liveTree) {
			for (int dir = 0; dir < 8; dir++) {
				nr = t.r + dr[dir];
				nc = t.c + dc[dir];

				if (!isPossi(nr, nc)) continue;
				trees[nr][nc].push_back(1);
			}
		}
	}

	// 정답 계산
	int ans = 0;
	for (int r = 1; r <= N; r++) {
		for (int c = 1; c <= N; c++)
			ans += trees[r][c].size();
	}

	return ans;
}

int main() {
	ios_base::sync_with_stdio(false);

	//input
	cin >> N >> M >> K;

	for (int r = 1; r <= N; r++) {
		for (int c = 1; c <= N; c++) {
			cin >> a[r][c];
			treeplus[r][c] = 5;
		}
	}

	int x, y, a;
	for (int i = 0; i < M; i++) {
		cin >> x >> y >> a;
		trees[x][y].push_back(a);
	}

	cout << Solve();

	return 0;
}
```
---------------------------
