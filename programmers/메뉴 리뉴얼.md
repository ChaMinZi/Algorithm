# [ë©”ë‰´ ë¦¬ë‰´ì–¼](https://programmers.co.kr/learn/courses/30/lessons/72411)


* ### C++

ì•„ë˜ì˜ ì½”ë“œëŠ” ëª¨ë“  ì¡°í•©ì˜ ìˆ˜ë¥¼ ì§ì ‘ êµ¬í•˜ëŠ” ì½”ë“œì´ì§€ë§Œ `<Algorithm>`í—¤ë”ì˜ `next_permutation` ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì´ìš©í•˜ë©´ ì¢€ ë” ê°„ë‹¨í•œ ì½”ë“œë¡œ ì¡°í•©ì„ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```c++
#include <string>
#include <vector>
#include <set>
#include <algorithm>
#include <iostream>
#include <queue>
#include <unordered_map>

using namespace std;

unordered_map<string, int> unMap;

void makeCombination(int idx, string order, int limit, int cur, string curString) {
    if (curString.size() == limit) {
        if (unMap.find(curString) != unMap.end())
            unMap[curString] += 1;
        else
            unMap.insert(make_pair(curString, 1));
        return;
    }
    else if (cur >= order.size()) 
        return;

    for (int i = cur; i < order.size(); i++) {
        makeCombination(idx, order, limit, i+1, curString + order.substr(i, 1));
    }
}

bool compare(string a, string b) {
    return a < b;
}

vector<string> solution(vector<string> orders, vector<int> course) {
    vector<string> answer;
    set<string> res;

    for (int i = 0; i < orders.size(); i++) {
        sort(orders[i].begin(), orders[i].end());
        for (int c = 0; c < course.size(); c++) {
            makeCombination(i, orders[i], course[c], 0, "");
        }
    }

    bool flag = false;
    for (auto iter1 : unMap) {
        flag = true;
        if (iter1.second > 1) {
            for (auto iter2 : unMap) {
                if (iter2.second < 2) continue;
                if (iter1.first == iter2.first) continue;
                
                // ì½”ìŠ¤ ê¸¸ì´ê°€ ê°™ì€ ê²½ìš°, íšŸìˆ˜ê°€ ì ìœ¼ë©´ ë¹ ì§„ë‹¤.
                if (iter1.first.size() == iter2.first.size() && iter1.second < iter2.second) {
                    flag = false;
                    break;
                }
                // ë‹¤ë¥¸ ë©”ë‰´ ì•ˆì— í¬í•¨ë˜ëŠ” ê²½ìš° ì œì™¸ì‹œí‚¨ë‹¤.
                if (iter1.second < iter2.second && iter2.first.find(iter1.first, 0) != string::npos) {
                    flag = false;
                    break;
                }
            }

            if (flag)
                answer.push_back(iter1.first);

        }
    }

    sort(answer.begin(), answer.end(), compare);

    return answer;
}
```

<br>

## ğŸ“Œ ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ì¡°í•© êµ¬í•˜ê¸°

`prev_permutation`, `next_permutation`ëŠ” ìˆœì—´ì„ êµ¬í•˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ì´ì§€ë§Œ ì´ë¥¼ ì´ìš©í•´ì„œ ì¡°í•©ë„ êµ¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

```C++
for (int i = 0; i < orders.size(); i++) {
        sort(orders[i].begin(), orders[i].end());
        string& order = orders[i];
        
        for (int c = 0; c < course.size(); c++) {
            if (order.size() < course[c]) continue;
            vector<int> chk(order.size(), 0);

            for (int j = 0; j < course[c]; j++) chk[j] = 1;
          
            // ì¡°í•© êµ¬í•˜ê¸°
            do {
                string temp = "";
                for (int j = 0; j < order.size(); j++) {
                    if (chk[j] == 1)
                        temp += order[j];
                }

                if (unMap.find(temp) != unMap.end())
                    unMap[temp] += 1;
                else
                    unMap.insert(make_pair(temp, 1));
            } while (prev_permutation(chk.begin(), chk.end()));
        }
    }
```
