# [단속 카메라]()

* ### C++ - 내 풀이

![image](https://user-images.githubusercontent.com/29828988/136527691-a563885c-f6d3-4ceb-8d3a-5879248af1c1.png)

현재 (cs)---(ce)를 기준으로 다음에 올 수 있는 차량의 경로는 위와 같이 3가지로 나뉩니다.

1️⃣ (ns)---(ne)가 현재 경로에 포함되는 경우  
2️⃣ (ns)---(ne)가 현재 경로에 걸처져 있는 경우  
3️⃣ (ns)---(ne)가 현재 경로와 분리된 경우

이때, 3️⃣번 케이스에서는 완전히 경로가 분리되는 것이므로 감시카메라의 개수를 늘려줘야 합니다.

1️⃣번 케이스의 경우, (ce)에 위치해있던 카메라의 위치를 (ne)로 변경해주기만 해도 2대의 차량을 감시할 수 있으므로 감시카메라 개수는 수정하지 않고 위치만 수정해줍니다.

```c++
#include <vector>
#include <queue>
#include <iostream>
#include <algorithm>

using namespace std;

bool compare(vector<int> a, vector<int> b) {
    if (a[0] == b[0])
        return a[1] < a[1];
    return a[0] < b[0];
}

int solution(vector<vector<int>> routes) {
    int answer = 1;

    sort(routes.begin(), routes.end(), compare);

    int e, n;
    n = routes.size();
    e = routes[0][1];

    for (int i = 0; i < n; i++) {
        if (e < routes[i][0]) {
            ++answer;
            e = routes[i][1];
        }
        else if (routes[i][1] < e)
            e = routes[i][1];
    }

    return answer;
}
```

* ### C++ - 다른 사람의 풀이!

이 풀이가 위의 풀이보다 더 좋을 것 같다.

```c++
#include <bits/stdc++.h>

using namespace std;

bool cmp(vector<int> a, vector<int> b) { return a[1] < b[1]; }

int solution(vector<vector<int>> routes) {
    int answer = 0;
    int limit = -30001;
    sort(routes.begin(), routes.end(), cmp);
    for(int i = 0; i < routes.size(); i++){
        if(limit < routes[i][0]){
            answer++;
            limit = routes[i][1];
        }
    }
    return answer;
}
```
